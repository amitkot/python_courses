---
theme: default
layout: cover
title: Advanced Features - Metaprogramming
---

# Advanced Features: Metaprogramming
---

# Agenda

- Class customizations with metaclasses
- Dynamic attribute access with getattr and getattribute
- Runtime class modification
- Practical use cases

---
# Basic Metaclass Structure

```python
class MyMeta(type):
    def __new__(mcs, name, bases, namespace):
        print(f"Creating class: {name}")
        # Modify namespace before class creation
        namespace["added_by_meta"] = "I was added by the metaclass"
        return super().__new__(mcs, name, bases, namespace)

    def __init__(cls, name, bases, namespace):
        print(f"Initializing class: {name}")
        super().__init__(name, bases, namespace)


class MyClass(metaclass=MyMeta):
    x = 1

    def method(self):
        return "Hello"


# Output:
# Creating class: MyClass
# Initializing class: MyClass

obj = MyClass()
print(obj.added_by_meta)  # Output: I was added by the metaclass
```

---
# Q&A

<div class="text-xs opacity-60 absolute bottom-2 right-2">Photo: flickr.com/photos/21560098@N06/3836926854</div>
---
# getattr and __getattribute__

- `getattr(obj, name, default)`: Get an attribute value, with optional default if not found
- `obj.__getattribute__(name)`: Called for every attribute access
- `obj.__getattr__(name)`: Called when attribute is not found through normal lookup
---
# Q&A

<div class="text-xs opacity-60 absolute bottom-2 right-2">Photo: flickr.com/photos/21560098@N06/3836926854</div>
---
# Runtime Class Modification Examples

## Dynamic attribute addition/modification

```python
class MyClass:
    pass


# Runtime modification
MyClass.new_attribute = "Added dynamically"
MyClass.some_method = (
    lambda self: "Dynamic method"
)
```
---
# Monkey Patching Example

## Monkey patching

```python
# Original behavior
import datetime

original_method = datetime.datetime.now

# Modified behavior
def patched_now():
    return original_method() + datetime.timedelta(
        days=1
    )


datetime.datetime.now = (
    patched_now  # Runtime modification
)
```
---
# Class Decorator Example

```python
def add_logging(cls):
    original_methods = {}
    for name, method in cls.__dict__.items():
        if callable(method):
            original_methods[name] = method
            
            def logged_method(self, *args, **kwargs):
                print(f"Calling {name}")
                return original_methods[name](self, *args, **kwargs)
            
            setattr(cls, name, logged_method)
    return cls

@add_logging
class MyClass:
    def method(self):
        return "Original behavior"
```
---
# Dynamic Class Creation

## Using type() for dynamic class creation

```python
# Creating a class at runtime
DynamicClass = type(
    "DynamicClass",
    (object,),
    {
        "attribute": 42,
        "method": lambda self: "Dynamic behavior",
    },
)
```
---
# type(name, bases, namespace)

```python
name - string with the name of the new class ⟹ becomes __name__
bases - list or tuple of the base classes ⟹ becomes __bases__
namespace - dictionary of the class body ⟹ becomes __dict__
```

---
layout: two-cols
---

# Traditional Class Definition vs type()

::left::

## Traditional approach

```python
class Person:
    def is_alive(self):
        return True


class Student(Person):
    def __init__(self, name, grades):
        self.name = name
        self.grades = grades

    def is_passing(self):
        return all(
            g > 55 for g in self.grades
        )
```

```python
>>> s = Student("Dan", [66, 77, 88, 99])
>>> print(s.name)
Dan
>>> print(s.is_passing()) True
```

::right::

## Using type()

```python
def student_init(self, name, grades):
    self.name = name
    self.grades = grades

Student = type(
    "Student",
    (Person,),
    {
        "__init__": student_init,
        "is_passing": lambda self: all(
            g > 55 for g in self.grades
        ),
    },
)
```

```python
>>> s = Student("Dan", [66, 77, 88, 99])
>>> print(s.name)
Dan
>>> print(s.is_passing()) True
```
---
# Q&A

<div class="text-xs opacity-60 absolute bottom-2 right-2">Photo: flickr.com/photos/21560098@N06/3836926854</div>
---
# ORM Pattern Example

```python
class Model:
    def __init__(self, **kwargs):
        for key, value in kwargs.items():
            setattr(self, key, value)

    def __getattr__(self, name):
        # Called when attribute doesn't exist
        return f"Field '{name}' not set"

user = Model(name="Alice", age=25)
print(user.name)     # Alice
print(user.email)    # Field 'email' not set
```
---
# Q&A

<div class="text-xs opacity-60 absolute bottom-2 right-2">Photo: flickr.com/photos/21560098@N06/3836926854</div>
---
# Creating Classes

When Python sees the class keyword, it:

1. Collects:
   - Class name
   - Base classes
   - A dict of all class attributes (functions, variables)
   - The metaclass (with type as default)
2. Calls `metaclass(name, bases, attrs_dict)`
---
# Calling type

```text
When type is called, its __call__() function is called, and it calls:
__new__()
__init__()
```
---
# Setting up a metaclass

```python
# Python 2
class Python2Class(object):
    __metaclass__ = SomeMetaclass
```

```python
# Python 3
class Python3Class(metaclass=SomeMetaclass):
    pass
```

```python
class SomeMetaclass(type):
    pass
```

```text
__call__()
__new__()
__init__()
```
---
# Metaclass functions

```text
__new__()
__init__()
__call__()
```
---
# Metaclass __new__()

Called when defining a new class, allocates and returns the class object
---
# __new__()

```python
class MyMeta(type):
    def __new__(cls, name, bases, dct):
        print("
---
Starting MyMeta __new__()")
        print(f"__new__: cls is {cls}")
        print(f"__new__: name is {name}")
        print(f"__new__: bases is {bases}")
        print(f"__new__: dct is {dct}")

        return super().__new__(cls, name, bases, dct)

class MyBase:
    pass

class MyClass(MyBase, metaclass=MyMeta):
    def __init__(self, a, b):
        pass
```

```text
---
Starting MyMeta __new__()
__new__: cls is <class '__main__.MyMeta'>
__new__: name is MyClass
__new__: bases is (<class '__main__.MyBase'>,)
__new__: dct is {'__module__': '__main__', '__qualname__': 'MyClass', '__init__': <function MyClass.__init__ at 0x1074470e0>}
```

```text
__call__()
__new__()
__init__()
```
---
# Metaclass __init__()

Called when defining a new class, receives an allocated class and sets up its attributes (functions, class variables)
---
# __init__()

```python
class MyMeta(type):
    def __init__(cls, name, bases, dct):
        print("
---
Starting MyMeta __init__()")
        print(f"__init__: cls is {cls}")
        print(f"__init__: name is {name}")
        print(f"__init__: bases is {bases}")
        print(f"__init__: dct is {dct}")

        super().__init__(name, bases, dct)

class MyBase:
    pass

class MyClass(MyBase, metaclass=MyMeta):
    def __init__(self, a, b):
        pass
```

```text
---
Starting MyMeta __init__()
__init__: cls is <class '__main__.MyClass'>
__init__: name is MyClass
__init__: bases is (<class '__main__.MyBase'>,)
__init__: dct is {'__module__': '__main__', '__qualname__': 'MyClass', '__init__': <function MyClass.__init__ at 0x1074470e0>}
```

```text
__call__()
__new__()
__init__()
```
---
# Metaclass __call__()

Called when creating an instance of the class, receives the arguments required for calling NewClass.__init__()
---
# __call__()

```python
class MyMeta(type):
    def __call__(cls, *args, **kwargs):
        print("
---
Starting MyMeta __call__()")
        print(f"__call__: cls is {cls}")
        print(f"__call__: args is {args}")
        print(f"__call__: kwargs is {kwargs}")

        super().__call__(*args, **kwargs)


class MyBase:
    pass

class MyClass(MyBase, metaclass=MyMeta):
    def __init__(self, a, b):
        pass
```

```python
>>> c = MyClass(11, 22)
---
Starting MyMeta __call__()
__call__: cls is <class '__main__.MyClass'>
__call__: args is (11, 22)
__call__: kwargs is {}
```

```text
__call__()
__new__()
__init__()
```
---
# Metaclass - summary

```python
__new__(): Called when defining a new class, returns the class instance
__init__(): Called when defining a new class, receives an allocated class and sets up its attributes (functions, class variables)
__call__(): Called when creating an instance of the class, receives the arguments required for calling NewClass.__init__()
```
---
# class MyMeta(type):
    def __new__(cls, name, bas...

```python
class MyMeta(type):
    def __new__(cls, name, bases, dct):
        print("
---
Starting MyMeta __new__()")
        print(f"__new__: cls is {cls}")
        print(f"__new__: name is {name}")
        print(f"__new__: bases is {bases}")
        print(f"__new__: dct is {dct}")
        return super().__new__(cls, name, bases, dct)

    def __init__(cls, name, bases, dct):
        print("
---
Starting MyMeta __init__()")
        print(f"__init__: cls is {cls}")
        print(f"__init__: name is {name}")
        print(f"__init__: bases is {bases}")
        print(f"__init__: dct is {dct}")
        super().__init__(name, bases, dct)

    def __call__(cls, *args, **kwargs):
        print("
---
Starting MyMeta __call__()")
        print(f"__call__: cls is {cls}")
        print(f"__call__: args is {args}")
        print(f"__call__: kwargs is {kwargs}")
        super().__call__(*args, **kwargs)

class MyBase:
    pass

class MyClass(MyBase, metaclass=MyMeta):
    def __init__(self, a, b):
        pass

print("=== Finished defining MyClass ===")
c = MyClass(11, 22)
```

```text
__call__()
```

```text
__call__()
__new__()
__init__()
```
---

```text
Starting MyMeta __new__()
__new__: cls is <class '__main__.MyMeta'>
__new__: name is MyClass
__new__: bases is (<class '__main__.MyBase'>,)
__new__: dct is {'__module__': '__main__', '__qualname__': 'MyClass', '__init__': <function MyClass.__init__ at 0x107434200>}
---
Starting MyMeta __new__()
__new__: cls is <class '__main__.MyMeta'>
__new__: name is MyClass
__new__: bases is (<class '__main__.MyBase'>,)
__new__: dct is {'__module__': '__main__', '__qualname__': 'MyClass', '__init__': <function MyClass.__init__ at 0x107434200>}
---
Starting MyMeta __init__()
__init__: cls is <class '__main__.MyClass'>
__init__: name is MyClass
__init__: bases is (<class '__main__.MyBase'>,)
__init__: dct is {'__module__': '__main__', '__qualname__': 'MyClass', '__init__': <function MyClass.__init__ at 0x107434200>}

=== Finished defining MyClass ===
---
Starting MyMeta __call__()
__call__: cls is <class '__main__.MyClass'>
__call__: args is (11, 22)
__call__: kwargs is {}
```

```text
__call__()
```

```text
__call__()
__new__()
__init__()
```
---
# Hebrew Dates Example

## Back to the Hebrew Dates Example

Let's use a metaclass to optionally add our hebrew_date() method

```python
def hebrew_date():
    return "29 Tevet 5816"

def support_hebrew():
   with open("locale.cfg") as f:
        return f.read().lower().startswith("he_")


class MaybeSupportHebrew(type):
    def __init__(cls, name, bases, dct):
        super().__init__(name, bases, dct)
        if support_hebrew():
            cls.hebrew_date = staticmethod(hebrew_date)


class ProvideDate:
    @staticmethod
    def gregorian_date():
        return "18 January 2056"


class CalendarApp(ProvideDate, metaclass=MaybeSupportHebrew):
    pass

class MailApp(ProvideDate, metaclass=MaybeSupportHebrew):
    pass

class JournalApp(ProvideDate, metaclass=MaybeSupportHebrew):
    pass
```

```text
__call__()
```

```text
__call__()
__new__()
__init__()
```
---
# Case study - Singleton

## Implementation Options

1. Metaclasses
2. Class decorators
---
# (1) Singleton using Metaclass

Strategy:
- Use a metaclass with a dict mapping classes to their instances
- When creating an instance of a class with this metaclass:
  - If dict has this class → return that instance
  - Otherwise → create an instance and add to dict
---
# (1) Singleton using Metaclass

```python
class SingletonMetaclass(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
       if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class H(metaclass=SingletonMetaclass):
    pass

class J(metaclass=SingletonMetaclass):
    pass
```

```python
>>> id(H()), id(H()), id(J()), id(J())
(4417199056, 4417199056, 4416182352, 4416182352)
```
---
# (2) Singleton using a Class Decorator

```python
def singleton_decorator(cls):
    def wrap_cls_new(cls, *args, **kwargs):
        if not hasattr(cls, "_instance"):
            cls._instance = cls._orig_new(cls, *args, **kwargs)
        return cls._instance

    cls._orig_new = cls.__new__
    cls.__new__ = wrap_cls_new
    return cls
```

```python
@singleton_decorator
class K:
    pass

>>> k1 = K()
>>> k2 = K()
>>> id(k1), id(k2)
(4420121488, 4420121488)
```
---
# (3) Singleton using Inheritance

```python
class Singleton:
    _instance = None
    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = object.__new__(
                cls, *args, **kwargs
            )
        return cls._instance
```

```python
>>> class SingletonClass(Singleton):
...     pass

>>> x1 = SingletonClass()
>>> x2 = SingletonClass()
>>> id(x1), id(x2)
(4417229392, 4417229392)
```
---
# Good use cases for Metaclasses

- Developing frameworks and APIs
- Lazily applying changes to all inheriting classes
- Logging, profiling
---
# Metaclass Example - final

## Final metaclass implementation

Emulate Java's final in Python - block class inheritance

```python
class final(type):
    def __init__(cls, name, bases, namespace):
       for base in bases:
            if isinstance(base, final):
                raise TypeError(str(base.__name__) + " is final")
       super().__init__(name, bases, namespace)
```
---
# class final(type):
    def __init__(cls, name, bas...

```python
class final(type):
    def __init__(cls, name, bases, namespace):
       for base in bases:
            if isinstance(base, final):
                raise TypeError(str(base.__name__) + " is final")
       super().__init__(name, bases, namespace)
```

```python
>>> class A:
...     pass

>>> class B(A):
...     pass

>>> class C(metaclass=final):
...     pass

>>> class D(C):
...     pass
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 6, in __init__
TypeError: C is final
```
---
# Metaclass and Inheritance

## Metaclass inheritance rules

When inheriting a base class, the inheriting class's metaclass must inherit the base class's metaclass
---
# class Meta1(type):
    def __init__(cls, name, bas...

```python
class Meta1(type):
    def __init__(cls, name, bases, dct):
        super().__init__(name, bases, dct)
        print("Meta1.__init__()")

class Meta2(type):
    def __init__(cls, name, bases, dct):
        super().__init__(name, bases, dct)
        print("Meta2.__init__()")
```

```python
>>> class A(metaclass=Meta1):
...     pass
...
Meta1.__init__()


>>> class B(A, metaclass=Meta2):
...     pass
...
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
```
---
# Q&A

<div class="text-xs opacity-60 absolute bottom-2 right-2">Photo: flickr.com/photos/21560098@N06/3836926854</div>
---
# Summary

- Python classes are instances of a metaclass
- `type` is the default metaclass
- Class decorators can modify class definitions
- Metaclasses can change classes during definition (`__new__()`, `__init__()`) and call (`__call__()`)
- Metaclasses are inherited by extending classes
---
# Q&A
---
# Thanks!

twitter		@amitkot
www		amitkot.com
